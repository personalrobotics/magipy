"""
Define PlanAction, PlanEndEffectorStraight, PlanToTSRAction, PlanSolution, and
PlanExecutableSolution.
"""

import logging

from openravepy import Robot
from prpy.planning import PlanningError
from prpy.planning.base import Tags
from prpy.util import CopyTrajectory, SetTrajectoryTags, GetTrajectoryTags, Timer
import prpy

from magi.actions.base import Action, ActionError, ExecutableSolution, Solution, from_key, to_key
from magi.logging_utils import log_execution_data, log_plan_data, log_postprocess_data

LOGGER = logging.getLogger(__name__)


class PlanExecutableSolution(ExecutableSolution):
    """An ExecutableSolution that calls a specific planner method."""

    def __init__(self, solution, traj):
        """
        @param solution: Solution that generated this ExecutableSolution
        @param traj: planned trajectory to execute
        """
        super(PlanExecutableSolution, self).__init__(solution)
        self.traj = traj

    @property
    def action(self):
        """
        Return the solution's Action.

        @return PlanSolution
        """
        return self.solution.action

    def execute(self, env, simulate):
        """
        Execute the planned trajectory. Record and log timing data for
        execution of this trajectory.

        @param env: OpenRAVE environment
        @param simulate: flag to run in simulation
        @return the executed trajectory
        """
        robot = self.action.get_robot(env)

        traj_copy = CopyTrajectory(self.traj, env=env)
        with Timer() as timer:
            traj = robot.ExecuteTrajectory(traj_copy)
        SetTrajectoryTags(
            traj, {Tags.EXECUTION_TIME: timer.get_duration()}, append=True)

        log_execution_data(traj, self.action.get_name())

        return traj


class PlanSolution(Solution):
    """A Solution that calls a specific planner method."""

    def __init__(self, action, path, deterministic):
        """
        @param action: Action that generated this Solution
        @param path: path generated by the Action
        @param deterministic: True if this solution was computed
          deterministically
        """
        super(PlanSolution, self).__init__(action, deterministic=deterministic)
        self.path = path

    def save(self, env):
        """
        Return a context manager that saves the current robot configuration
        (LinkTransformation).

        @param env: OpenRAVE environment
        @return a RobotStateSaver that saves the current configuration
        """
        return self.action.get_robot(env).CreateRobotStateSaver(
            Robot.SaveParameters.LinkTransformation)

    def jump(self, env):
        """
        Move the robot to the last configuration in the path.

        @param env: OpenRAVE environment
        """
        robot = self.action.get_robot(env)

        with robot.CreateRobotStateSaver(Robot.SaveParameters.ActiveDOF):
            robot.SetActiveDOFs(self.action.active_indices)
            cspec = robot.GetActiveConfigurationSpecification()

            lastconfig = self.path.GetWaypoint(self.path.GetNumWaypoints() - 1, cspec)
            robot.SetActiveDOFValues(lastconfig)

    def postprocess(self, env):
        """
        Perform post-processing and timing on the path to produce a trajectory.
        Record and log timing data for the postprocessing.

        @param env: OpenRAVE environment
        @return a PlanExecutableSolution containing the trajectory produced by
          the postprocessing
        """
        robot = self.action.get_robot(env)

        with robot.CreateRobotStateSaver(Robot.SaveParameters.ActiveDOF):
            path_copy = CopyTrajectory(self.path, env=env)
            with Timer() as timer:
                traj = robot.PostProcessPath(path_copy, timelimit=5.)

            SetTrajectoryTags(
                traj, {Tags.POSTPROCESS_TIME: timer.get_duration()},
                append=True)

            log_postprocess_data(traj, self.action.get_name())

        return PlanExecutableSolution(solution=self, traj=traj)


class PlanAction(Action):
    """An Action that calls a specific planner method."""

    def __init__(self,
                 robot,
                 active_indices,
                 active_manipulator,
                 method,
                 args=None,
                 kwargs=None,
                 planner=None,
                 name=None,
                 checkpoint=False):
        """
        @param robot: robot
        @param active_indices: indices of the robot that should be active during
          planning
        @param active_manipulator: manipulator of the robot that should be
          active during planning
        @param method: planning method to call (e.g. 'PlanToConfiguration')
        @param args: arguments to pass to the planning method
        @param kwargs: keyword arguments to pass to the planning method
        @param planner: specific planner to look up the planning method from
          if None, robot.planner is used
        @param name: name of the action
        @param checkpoint: True if this action is a checkpoint
        """
        super(PlanAction, self).__init__(name=name, checkpoint=checkpoint)

        self._robot = to_key(robot)
        self.active_indices = active_indices
        self._active_manipulator = to_key(active_manipulator)
        self.method = method

        # TODO: Some entries in here need to be wrapped with to_key.
        self.args = args if args is not None else list()
        self.kwargs = kwargs if kwargs is not None else dict()
        self.planner = planner

    def get_robot(self, env):
        """
        Look up and return the robot in the environment.

        @param env: OpenRAVE environment
        @return an OpenRAVE robot
        """
        return from_key(env, self._robot)

    def get_manipulator(self, env):
        """
        Look up and return the manipulator in the environment.

        @param env: OpenRAVE environment
        @return an OpenRAVE manipulator
        """
        return from_key(env, self._active_manipulator)

    def plan(self, env):
        """
        Execute the defined planning method on the defined planner.

        @param env: OpenRAVE environment
        @return a PlanSolution
        @throws an ActionError if an error is encountered while planning
        """
        robot = self.get_robot(env)
        active_manipulator = self.get_manipulator(env)
        planner = self.planner if self.planner is not None else robot.planner

        with robot.CreateRobotStateSaver(
            Robot.SaveParameters.ActiveDOF
            | Robot.SaveParameters.ActiveManipulator):

            robot.SetActiveDOFs(self.active_indices)

            if active_manipulator is not None:
                robot.SetActiveManipulator(active_manipulator)

            planning_method = getattr(planner, self.method)
            try:
                with Timer() as timer:
                    path = planning_method(robot, *self.args, **self.kwargs)
                SetTrajectoryTags(
                    path, {Tags.PLAN_TIME: timer.get_duration()}, append=True)

                # Mark this action as deterministic based on the traj tags
                path_tags = GetTrajectoryTags(path)
                deterministic = path_tags.get(Tags.DETERMINISTIC_ENDPOINT, None)
                if deterministic is None:
                    LOGGER.warn(
                        "Trajectory does not have DETERMINISTIC_ENDPOINT flag set. "
                        "Assuming non-deterministic.")
                    deterministic = False

                log_plan_data(path, self.get_name())

            except PlanningError as err:
                raise ActionError(str(err), deterministic=err.deterministic)

        return PlanSolution(
            action=self, path=path, deterministic=deterministic)


class PlanToTSRAction(PlanAction):
    """An Action that calls a planner's PlanToTSR method."""

    def __init__(self,
                 robot,
                 obj,
                 tsr_name,
                 active_indices,
                 active_manipulator,
                 tsr_args=None,
                 args=None,
                 kwargs=None,
                 planner=None,
                 name=None):
        """
        @param robot: robot
        @param obj: object the TSR is defined on
        @param tsr_name: name of the TSR
        @param active_indices: indices of the robot that should be active during
          planning
        @param active_manipulator: manipulator of the robot that should be
          active during planning
        @param tsr_args: extra arguments to pass to the TSR library for
          computing the TSR
        @param args: arguments to pass to the planning method
        @param kwargs: keyword arguments to pass to the planning method
        @param planner: specific planner to look up the planning method from
          if None, robot.planner is used
        @param name: name of the action
        """
        super(PlanToTSRAction, self).__init__(
            robot,
            active_indices,
            active_manipulator,
            method='PlanToTSR',
            args=args,
            kwargs=kwargs,
            planner=planner,
            name=name)
        self._obj = to_key(obj)
        self.tsr_name = tsr_name
        self.orig_args = args if args is not None else list()
        self.tsr_args = tsr_args if tsr_args is not None else dict()

    def get_obj(self, env):
        """
        Look up and return the object in the environment.

        @param env: OpenRAVE environment
        @return KinBody that the TSR is defined on
        """
        return from_key(env, self._obj)

    def plan(self, env):
        """
        Look up the appropriate TSR in the tsrlibrary, then plan to that TSR.

        @param env: OpenRAVE environment
        @return a PlanSolution
        @throws an ActionException if an error is encountered during planning
        """
        obj = self.get_obj(env)
        robot = self.get_robot(env)
        active_manipulator = self.get_manipulator(env)

        if active_manipulator is not None:
            self.tsr_args['manip'] = active_manipulator

        tsr_list = robot.tsrlibrary(obj, self.tsr_name, **self.tsr_args)
        self.args = [tsr_list] + self.orig_args

        with prpy.viz.RenderTSRList(tsr_list, env):
            return super(PlanToTSRAction, self).plan(env)


class PlanEndEffectorStraight(PlanAction):
    """An Action that calls a planner's PlanToEndEffectorOffset method."""

    def __init__(self,
                 robot,
                 active_indices,
                 active_manipulator,
                 distance,
                 args=None,
                 kwargs=None,
                 planner=None,
                 name=None):
        """
        @param robot: robot
        @param active_indices: indices of the robot that should be active during
          planning
        @param active_manipulator: manipulator of the robot that should be
          active during planning
        @param distance: distance to move the end-effector
        @param args: arguments to pass to the planning method
        @param kwargs: keyword arguments to pass to the planning method
        @param planner: specific planner to look up the planning method from
          if None, robot.planner is used
        @param name: name of the action
        """
        super(PlanEndEffectorStraight, self).__init__(
            robot,
            active_indices,
            active_manipulator,
            method='PlanToEndEffectorOffset',
            args=args,
            kwargs=kwargs,
            planner=planner,
            name=name)
        self.distance = distance

    def plan(self, env):
        """
        Plan a trajectory that moves the specified distance.

        @param env: OpenRAVE environment
        @return a PlanSolution object
        @throws an ActionException if an error is encountered during planning
        """
        active_manipulator = self.get_manipulator(env)

        # Move in the direction of the z-axis of the manipulator
        direction = active_manipulator.GetEndEffectorTransform()[0:3, 2]
        self.kwargs['direction'] = direction
        self.kwargs['distance'] = self.distance

        return super(PlanEndEffectorStraight, self).plan(env)
